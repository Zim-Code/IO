using System;
using System.Reflection;
using System.Threading.Tasks;

namespace ZimCode.IO
{
    /// <summary>
    /// Operations are used to execute in sequence passing params from one to another.
    /// </summary>
    public class Operation
    {
        Action action;

        internal Operation(Type paramType = null, Type returnType = null)
        {
            ParamType = paramType;
            ReturnType = returnType;
        }

        private Operation(Action action)
        {
            if (action == null)
                throw new ArgumentNullException(nameof(action));
            this.action = action;
        }

        /// <summary>
        /// Gets the type of the parameter.
        /// </summary>
        /// <value>The type of the parameter; null if there is no parameter.</value>
        public Type ParamType { get; private set; } 

        /// <summary>
        /// Gets the type of the return.
        /// </summary>
        /// <value>The type of the return value; null if it does not have a return value.</value>
        public Type ReturnType { get; private set; }

        internal virtual object ExecuteCore(object param)
        {
            action.Invoke();
            return null;
        }

        internal Task<object> ExecuteAsync(object param)
        {
            return Task.Factory.StartNew(() =>
                {
                    CheckParamType(param?.GetType());
                    return ExecuteCore(param);
                });
        }

        private void CheckParamType(Type paramType)
        {
            if (ParamType == null)
                return;
            if (!ParamType.GetTypeInfo().IsAssignableFrom(paramType.GetTypeInfo()))
                throw new ArgumentException(
                    $"The provided argument of type {paramType.FullName} " + 
                    $"does not match the expected param type of {ParamType.FullName}.");
        }

        internal bool IsValidReturnValue(Type returnType)
        {
            if (ReturnType == null)
                return true;
            return returnType.GetTypeInfo().IsAssignableFrom(ReturnType.GetTypeInfo());
        }

        /// <summary>
        /// Do the specified action. This operation will not provide a parameter to the next operation.
        /// </summary>
        /// <param name="action">Action.</param>
        public static Operation Do(Action action)
        {
            return new Operation(action);
        }

        /// <summary>
        /// Consume the result generated by the last run Operation. This operation will not provide a 
        /// parameter to the next operation.
        /// </summary>
        /// <param name="action">Action.</param>
        /// <typeparam name="TParam">The parameter type.</typeparam>
        public static Operation Consume<TParam>(Action<TParam> action)
        {
            return new ConsumeOperation<TParam>(action);
        }

        /// <summary>
        /// Consumes the result generated by the last operation and generate a result for the next
        /// Operation.
        /// </summary>
        /// <returns>The generate.</returns>
        /// <param name="func">Func.</param>
        /// <typeparam name="TParam">The parameter type.</typeparam>
        /// <typeparam name="TResult">The result type.</typeparam>
        public static Operation ConsumeGenerate<TParam, TResult>(Func<TParam, TResult> func)
        {
            return new GenerateOperation<TParam, TResult>(func);
        }

        /// <summary>
        /// Generate a result for the next operation.
        /// </summary>
        /// <param name="func">Func.</param>
        /// <typeparam name="TResult">The result type.</typeparam>
        public static Operation Generate<TResult>(Func<TResult> func)
        {
            return new GenerateOperation<object, TResult>((o) => func());
        }
    }

    class ConsumeOperation<TParam> : Operation
    {
        Action<TParam> action;

        internal ConsumeOperation(Action<TParam> action)
            : base(typeof(TParam))
        {
            if (action == null)
                throw new ArgumentNullException(nameof(action));
            this.action = action;
        }

        internal override object ExecuteCore(object param)
        {
            action((TParam)param);
            return null;
        }
    }

    class GenerateOperation<TParam, TResult> : Operation
    {
        Func<TParam, TResult> func;

        internal GenerateOperation(Func<TParam, TResult> func)
        {
            this.func = func;
        }

        internal override object ExecuteCore(object param)
        {
            return func.Invoke((TParam)param);
        }
    }
}

